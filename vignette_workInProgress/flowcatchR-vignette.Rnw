% \VignetteIndexEntry{flowcatchR: tracking and analyzing cells in time lapse microscopy images}
% \VignetteKeywords{tracking analyze cell time-lapse microscopy}
% \VignettePackage{flowcatchR}
% \VignetteEngine{knitr::knitr}

\documentclass[11pt,oneside]{article}

%%%%%%%%%%% additional/optional packages %%%%%%%%%%% 
% \usepackage{fancyhdr}
% for using cleverly the bibliography from mendeley 
\usepackage[backend=bibtex]{biblatex}
% put refs here
\bibliography{flowcatchR.bib}
%%%%%%%%%%% user defined commands %%%%%%%%%%% 
\newcommand{\bash}[1]{\texttt{#1}}
\newcommand{\TODO}[1]{{\textbf{TODO:} \textit{\textcolor{green}{#1}}}}
\newcommand{\pval}{$p$-value}
\newcommand{\flowcatchR}{\Biocpkg{flowcatchR}~}

% \newcommand{\thetitle}{flowcatchR: A framework for tracking and analyzing cells in time lapse microscopy images}


% \bioctitle{flowcatchR: asdadds  dd aads}
% \author{Federico Marini}
% \date{\today}
% \bioctitle{flowcatchR: A framework for tracking and analyzing cells in time lapse microscopy images}
% \author{Federico Marini$^1$, Johanna Mazur, Harald Binder \\ [1em]Institute of Medical Biostatistics, Epidemiology and Informatics (IMBEI), \\ University Medical Center - Mainz (Germany)\\[1em] \email{$^1$marinif@uni-mainz.de}}
% \date{\today}

<<style-knitr, eval=TRUE, echo=FALSE, results="asis">>=
BiocStyle::latex()
@

<<setup, include=FALSE, cache=FALSE, eval = TRUE, echo = FALSE>>=
library(knitr)
opts_chunk$set(fig.path='./figures/flowcatchR-',
               fig.align='center', fig.show='asis', #fig.show='hold',dev="png",
               eval = TRUE,
               fig.width = 4.5,
               fig.height = 4.5,
               tidy = FALSE,
               message = FALSE,
               warning = FALSE,
               size='small',
               comment='##',
               prompt=FALSE,
               echo=TRUE, # set to true for the vignette!
               results='hold')
options(replace.assign=TRUE,width=80)
@


% \bioctitle{flowcatchR: asdadds  dd aads}
% \author{Federico Marini}
% \date{\today}

\title{{\flowcatchR: A framework for tracking and analyzing cells in time lapse microscopy images}}
\author{Federico Marini$^1$, Johanna Mazur, Harald Binder \\ [1em]Institute of Medical Biostatistics, Epidemiology and Informatics (IMBEI), \\ University Medical Center - Mainz (Germany)\\[1em] \email{$^1$marinif@uni-mainz.de}}
\date{Edited: July 7, 2014; Compiled: \today}

\begin{document}

\maketitle



\begin{abstract}
\flowcatchR is a set of tools to analyze in vivo microscopy imaging data, focused on tracking flowing blood cells. It guides the steps from segmentation to calculation of features, filtering out particles not of interest, providing also a set of utilities to help checking the quality of the performed operations (e.g. how good the segmentation was). The main novel contribution investigates the issue of tracking flowing cells such as in blood vessels, to categorize the particles in flowing, rolling and adherent. This classification is applied in the study of phenomena such as hemostasis and study of thrombosis development.
\end{abstract}

<<loadlibraries,results='hide'>>=
library("flowcatchR")
@

\tableofcontents


\section{Introduction}
\flowcatchR is a set of tools to analyze in vivo microscopy imaging data, focused on tracking flowing blood cells. It guides the steps from segmentation to calculation of features, filtering out particles not of interest, providing also a set of utilities to help checking the quality of the performed operations (e.g. how good the segmentation was). The main novel contribution investigates the issue of tracking flowing cells such as in blood vessels, to categorize the particles in flowing, rolling and adherent. This classification is applied in the study of phenomena such as hemostasis and study of thrombosis development.

This document offers an introduction and overview of the \R{} \Bioconductor{} package \flowcatchR, which provides a set of tools to detect and track cells in time-lapse microscopy.

\flowcatchR builds upon functionalities provided by the \Biocpkg{EBImage} package, and extends them in order to analyze time-lapse microscopy images. Unique characteristics of the datasets \flowcatchR is designed for are listed here:

\begin{itemize}
\item Images come from intravital microscopy experiments. This means, SNR is not optimal, and very importantly there are potential major movements of the alive specimen, that can ba confounded with the true movements of the particles of interest
\item A relatively dense number of cells per image, with particles that can enter and leave the field of view
\item The acquisition frame rate is a compromise between allowing the fluorescent cells to be detected and detecting the movements properly (typical values range around ...\TODO{ask})
\item Cells can flow, temporarily adhere to the endothelial layer and/or be permanently adherent. Therefore, all movement modalities should be detected correctly throughout the entire acquisition. Cells can also cluster together and form (temporary) conglomerates
\end{itemize}


Essential features \Biocpkg{flowcatchR} delivers to the user are:

\begin{itemize}
\item A simple and flexible, yet complete framework to analyze time-lapse image sets , with classes such as \Rclass{FrameList}, \Rclass{ParticleList} and \Rclass{TrajectoryList} constituting the backbone of the procedure
\item Facilities for detection of objects in the segmentation step
\item An algorithm for tracking the particles, adapted and improved from Sbalzarini et al. (2005) \cite{Sbalzarini2005} \TODO{ fix how to use refs with knitr and bioc vignette}, that reflects the directional aspect of the motion
\item A set of functions inspecting the kinematic properties of the iehdentified trajectories, providing summary statistics and visualization tools to help classifying identified objects
\end{itemize}

This guide includes a brief overview of the entire processing flow, from raw images to analysis of kinematic parameters derived from the identified trajectories. An example dataset will be used to illustrate the available features, in order to track blood platelets in consecutive frames derived from an intravital microscopy acquisition (also available as a subset in the Data folder of the package). All steps will be dissected to explore parameters and options available.() A second example? ()Finally, a detailed explanation is given for the implementation of the algorithm used for particle tracking.

\section{Processing overview}\label{sec:overview}
\flowcatchR works primarily with sets of fluorescent time-lapse images, where the particles of interest are marked with a fluorescent label (e.g., red for blood platelets, green for leukocytes). Although different entry spots are provided (such as the coordinates of identified points in each frame via tab delimited files), we will illustrate the characteristics of the package starting from a set of 20 frames derived from an intravital microscopy acquisition, which for the sake of practicity were already registered to reduce the unwanted specimen movements. []ref to SPIM, imageJ \& co

<<loadData,results='hide'>>=
# library("flowcatchR")
load(file.path(system.file("extra", package="flowcatchR"),"MesenteriumSubset.RData"))
@

To obtain the set of trajectories identified from the analysis of the loaded frames, a 6-step (5 if the compacter version is selected) script is all that is needed:

<<workflowCompact,eval=FALSE,results='hide'>>=

# will need to change all this. ideally it would work with..
# one command to seize them all

fullResults <- kinematics(trajectories(particles(channels(MesenteriumSubset)$red)))

# separate the information into the three channels
allChannelsMesenterium <- channels(MesenteriumSubset)
# perform smoothing/segmentation on the red channel
preprocessedPlatelets <- preprocess(allChannelsMesenterium,channel="red")
# identify platelets and compute some features on them (will be used also for next steps)
particlesPlatelets <- particles(allChannelsMesenterium$red, # use just red channel
                                       preprocessedPlatelets)


# the same is achievable through 
particlesPlatelets <- particles(allChannelsMesenterium$red)


# the tracking is performed (see explanation for details on the parameters)
linkedPlatelets <- link.ParticleList(particlesPlatelets,
                                     L=26,R=3,epsilon1=0,epsilon2=0,lambda1=1,lambda2=0,
                                     nframes=20,useAreaChange=FALSE)
# the linked particle list is transformed into trajectories
trajectoryPlatelets <- generate.TrajectoryList(linkedPlatelets)
# computes a set of interesting kinematic parameters
kinematicsPlatelets <- extractKinematics(trajectoryPlatelets)
@

The following sections will provide additional detail to the steps mentioned above, with more also on the auxiliary function that are available in \flowcatchR.

<<testRun>>=
ptm <- proc.time()

fullResults <- kinematics(trajectories(particles(channels(MesenteriumSubset)$red)))

# Print elapsed time
elapsed = signif( (proc.time() - ptm)[['elapsed']], 5)
gc(reset=T, verbose=F)

elapsed

@


\section{Image Acquisition}
A set of images is acquired, after a proper microscopy setup has been performed. This includes for example a careful choice of spatial and temporal resolution; often a compromise must be met to have a good frame rate and a good Signal to Noise Ratio to detect the particles in the single frames. For a good review on the steps to be taken, please refer to Meijering's work \cite{Meijering2008}. 

\flowcatchR provides an S3 class that can store the information of a complete acquisition, namely \Rclass{FrameList}. A \Rclass{FrameList} object is structured as a list, whose elements are in turn a list too. The \Robject{image} and its \Robject{location} are stored in the respective slots. To construct a \Rclass{FrameList}, the \Rfunction{newFrameList} function is used:

<<newFrameList>>=
# path to the folder containing the images
# imgRepository <- list.files("/Volumes/users$/marinif/flow/test_28_03_2014/cutout2/",
#                             full.names=T,pattern="*.tif")

# initialization
fullData <- read.frames(image.files="/Volumes/users$/marinif/flow/test_28_03_2014/cutout2/",nframes=100)

# printing summary information for the FrameList object
fullData
@

\Robject{nframes} specifies the number of frames that will constitute the FrameList object, whereas \Robject{image.files} is a vector of character strings with the location of the (raw) images, or the path to the folder containing them (works automatically if images are in TIFF/JPG format). In this case we just loaded the full dataset, but for the demonstrational purpose of this vignette, we will proceed with the subset available in the MesenteriumSubset.RData object, which we previously loaded in Section \ref{sec:overview}.

It is possible to inspect the first frames of a FrameList object with the function inspect.frames.

<<inspectRaw>>=
inspect.frames(fullData,nframes=6,display.method="raster")
@

By default, display.method is set to "browser", as in the EBImage function display. This opens up a window in the predefined browser (e.g. Mozilla Firefox), with navigable frames (arrows on the top left corner).


\TODO{put all commandies to r fncs, objs, classes...}

Importantly, these image sets were already registered and rotated in such a way that the overall direction of the movement of interest flows from left to right, as a visual aid and also to fit with some assumptions that will be done in the subsequent step of particle tracking. To register the images, we recommend the general purpose suite offered by ImageJ/Fiji, in particular with the plugins ...

For the following steps, we will focus on the information contained in the red channel, corresponding in this case to blood platelets. We do so by calling:

<<decomposeChannels>>=
allChannelsMesenterium <- channels(MesenteriumSubset)

allChannelsMesenterium
@

This creates an object of the class ChannelsFrameList, which is in turn a list of three FrameList objects (one for each color channel).

<<selectRed>>=
plateletsMesenterium <- allChannelsMesenterium$red

plateletsMesenterium
@

As we can see, by selecting one of the channels, we get in return a FrameList object.

<<inspectPlatelets>>=
inspect.frames(plateletsMesenterium,nframes=6,display.method="raster")
@


\section{Image Preprocessing and Analysis}
Steps such as denoising, smoothing and morphological operations (erosion/dilation, opening/closing) can be performed thanks to the general functions provided by EBImage. \flowcatchR offers a wrapper around a series of operations to be applied to all images in a FrameList object. The generic function preprocess has a method for FrameList objects, which is called via the command:

<<segmentPreprocess>>=
preprocessedPlatelets <- preprocess.FrameList(plateletsMesenterium,
                                              brushSize = 3, brushShape = "disc",
                                              adaptOffset = 0.15, adaptWinWidth = 10, adaptWinHeight = 10,
                                              kernSize = 3, kernShape = "disc",
                                              watershedTolerance = 1, watershedRadius = 1,
                                              areaThresholdMin = 5, areaThresholdMax = 100)
preprocessedPlatelets
@

For a detailed explanation of the parameters to better tweak the performances of this segmentation step, please refer to the help of preprocess.FrameList. To obtain an immediate feedback about the effects of the operations performed in the full preprocessing phase, we can call again inspect.frames on the FrameList of segmented images.

<<inspectSegm>>=
inspect.frames(preprocessedPlatelets,nframes=6,display.method="raster")
@


% We also ported to the R language two widely adopted thresholding algorithms for gray-level images, namely the ones developed by Otsu (ref, 1979) and Kittler and Illingworth (ref, 1986), which despite their historical origin perform well with bimodal histograms such as fluorescent images. []say the names of the functions? 

The user can choose any combination of the operations in order to segment the images provided as input, but preprocess is a very convenient high level function for proceeding in the workflow. It is also possible, as it was shown in the introductory 5-step script, to call just ExtractParticles on the raw FrameList object. In this latter case, ExtractParticles computes the preprocessed FrameList object according to default parameters. Still, in either situation, the output for this step is an object of the ParticleList class.

<<particleList>>=
platelets <- particles(plateletsMesenterium,preprocessedPlatelets)

platelets
@

As it can be seen from the summary information, each ParticleList stores the essential information on all particles that were detected in the original images, alongside with a complete set of features, which are computed by integrating the information from both the raw and the segmented frames.

A ParticleList is also a list of lists, structured with the elements particles (storing the actual info), imgSource to help backtracking the operations performed, and channel, as selected in the initial steps.

It is possible to filter out particles according to their properties, such as area, shape and eccentricity. This is possible with the function select.particles. Currently the implementation regards only the surface extension, but any additional feature can be chosen and adopted to restrict the number of candidate particles according to particular properties which are expected and/or to remove potential noise that went through the preprocessing phase.

<<selectParticles>>=
selectedPlatelets <- select.particles(platelets,min.area=3)

selectedPlatelets
@

This step can be done iteratively, with the help of the function add.contours (2). \TODO{tell here about it already?}

To connect the particles from one frame to the other, we perform first the detection of particles on all images. Only in a successive phase, we establish the links between the so identified objects.

<<checkSelection>>=
paintedPlatelets <- add.contours2(raw.frames=MesenteriumSubset,
                                  binary.frames=preprocessedPlatelets,
                                  mode="particles")

inspect.frames(paintedPlatelets,nframes=6,display.method="raster")
@



<<allCode,eval=FALSE>>=
ffffg <- cut(x=frameList1,cutAll=20)

cc <- createChannelsFrameList(frameList1)

prepro <- preprocess.ChannelsFrameList(cc,"red")
framelistProcessed <- prepro
framelistRaw <- cc[[1]]

papa <- extractParticles(framelistRaw,framelistProcessed)

qaqa <- filterParticles(particlelist=papa)
# rara <- initialize.ParticleList(qaqa)

sasa <- link.ParticleList(qaqa,L=26,R=3,epsilon1=0,epsilon2=0,lambda1=1,lambda2=0,nframes=100,useAreaChange=FALSE)
tata <- generate.TrajectoryList(sasa)
  

rere <- paintTrajectory(tata,frameList1,framelistProcessed,trajId=3)
fullInspection.FrameList(rere)
segseg <- combine.preprocessedFrameList(frameList1,framelistProcessed) # if framelist raw is with colors, then also the output is..
inspect.FrameList(framelist=segseg)

segcsegc <- combineWcolor.preprocessedFrameList(frameList1,framelistProcessed)
inspect.FrameList(framelist=segcsegc)

display.TrajectoryList(tata,qaqa)


tataMOD <- evaluateTrajectoryList(tata,frameList1,framelistProcessed)
unlist(lapply(tataMOD,function(arg){arg$keep}))

# extractKinematics.traj(tata,1)â€°
# 
# extractKinematics.traj(tata,13)
# plot(extractKinematics.traj(tata,13)$trajMSD)
# rere2 <- paintTrajectory(tata,frameList1,framelistProcessed,trajId=13)
# fullInspection.FrameList(rere2)

# with the new code structure
wawa2 <- extractKinematics(tata)

extractKinematics.traj(tata,1)

extractKinematics.traj(tata,13)
plot(extractKinematics.traj(tata,13)$trajMSD)
rere2 <- paintTrajectory(tata,frameList1,framelistProcessed,trajId=13)
fullInspection.FrameList(rere2)

singleKFS <- extractKinematics(tata,13)
singleK_manyTrajs <- extractKinematics(tata,feature="curvilinearVelocity")
singleKF <- extractKinematics(tata,trajectoryID=13,feature="curvilinearVelocity")

@



\section{Particle tracking}
explanation of tracking algorithm approach
penalty generator



\section{Trajectory Analysis}
identified trajs, compute params
evaluate trajs



\section{Auxiliary functions}
inspectFramelist
print methods
subsetting

exportFramelis



\section{}



\section{}



\section{}



\section{}





\section{ff}
ffff ff ff
\subsection{gne gne}
gne





\TODO{auto sort references?}

\newpage
\section{Session Information}
<<sessioininfo,results='asis'>>=
toLatex(sessionInfo())
# Sys.time()
@

\printbibliography
% \bibliographystyle
% \bibliography{flowcatchR} % does not work!?
% 
% \begin{thebibliography}{9}
% 
% \bibitem{Sbalzarini2005} Ivo Sbalzarini, \emph{Differential expression analysis for sequence count data}, Genome Biology 2010, 11:R106
% \end{thebibliography}

\end{document}






