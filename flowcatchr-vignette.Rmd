---
title: 'flowcatchR: A framework for tracking and analyzing flowing blood cells in
  time lapse microscopy images'
author: "Federico Marini"
date: "6 October 2014"
output:
  html_document:
    highlight: pygments
    keep_md: yes
    theme: united
    toc: yes
  pdf_document:
    toc: yes
---
<!--
%\VignetteEngine{knitr::rmarkdown}
%\VignetteIndexEntry{flowcatchR-vignette}
-->
-----------------------------

## Introduction 

*flowcatchR* is a set of tools to analyze in vivo microscopy imaging data, focused on tracking flowing blood cells. *flowcatchR* guides throughout all the steps of bioimage processing, from segmentation to calculation of features, filtering out particles not of interest, providing also a set of utilities to help checking the quality of the performed operations. The main novel contribution investigates the issue of tracking flowing cells such as the ones in blood vessels, to categorize the particles in flowing, rolling, and adherent by providing a comprehensive analysis of the identified trajectories. The extracted information is then applied in the study of phenomena such as hemostasis and thrombosis development. We expect this package to be potentially applied to a variety of assays, covering a wide range of applications founded on time-lapse microscopy.


This document offers an introduction and overview of the R/Bioconductor package *flowcatchR*, which provides a flexible and comprehensive set of tools to detect and track flowing blood cells in time-lapse microscopy. 



*flowcatchR* builds upon functionalities provided by the *EBImage* package, and extends them in order to analyze time-lapse microscopy images. Here we list some of the unique characteristics of the datasets *flowcatchR* is designed for:

- The images come from intravital microscopy experiments. This means that the Signal-to-Noise Ratio (SNR) is not optimal, and very importantly there are potential major movements of the alive specimen, that can be confounded with the true movements of the particles of interest
- Cells are densely distributed on the images, with particles that can enter and leave the field of view
- The acquisition frame rate is a compromise between allowing the fluorescent cells to be detected and detecting the movements properly  
- Cells can flow, temporarily adhere to the endothelial layer and/or be permanently adherent. Therefore, all movement modalities should be detected correctly throughout the entire acquisition. Cells can also cluster together and form (temporary) conglomerates

Essential features *flowcatchR* delivers to the user are:

- A simple and flexible, yet complete framework to analyze flowing blood cells (and more generally time-lapse) image sets , with a system of S4 classes such as `Frames`, `ParticleSet` and `TrajectorySet` constituting the backbone of the procedures
- Techniques for aiding the detection of objects in the segmentation step
- An algorithm for tracking the particles, adapted and improved from the proposal of Sbalzarini and Koumoutsakos (2005), that reflects the directional aspect of the motion
- A wide set of functions inspecting the kinematic properties of the identified trajectories, providing publication-ready summary statistics and visualization tools to help classifying identified objects

This guide includes a brief overview of the entire processing flow, from importing the raw images to the analysis of kinematic parameters derived from the identified trajectories. An example dataset will be used to illustrate the available features, in order to track blood platelets in consecutive frames derived from an intravital microscopy acquisition (also available in the package). All steps will be dissected to explore available parameters and options.

To install the package *flowcatchR*, please start a current version of R and type 

```{r install,eval=FALSE}
source("http://bioconductor.org/biocLite.R")
biocLite("flowcatchR")
# currently this can be done via github
install.packages("devtools") # if needed
devtools::install_github("flowcatchR", "federicomarini")
```



## Processing overview

*flowcatchR* works primarily with sets of fluorescent time-lapse images, where the particles of interest are marked with a fluorescent label (e.g., red for blood platelets, green for leukocytes). Although different entry spots are provided (such as the coordinates of identified points in each frame via tab delimited files), we will illustrate the characteristics of the package starting from the common protocol starting point. In this case, we have a set of 20 frames derived from an intravital microscopy acquisition, which for the sake of practicality were already registered to reduce the unwanted specimen movements (Fiji was used for this purpose). 

```{r loadData,results='hide',message=TRUE}
library("flowcatchR")
data(MesenteriumSubset)
```

```{r meseLoaded}
# printing summary information for the MesenteriumSubset object
MesenteriumSubset
```

To obtain the set of trajectories identified from the analysis of the loaded frames, a very compact one-liner command is all that is needed:

```{rworkflowCompact,eval=FALSE,results='hide'}
# one command to seize them all :)
fullResults <- kinematics(trajectories(particles(channel.Frames(MesenteriumSubset,"red"))))
```


On a MAC OS X machine equipped with 2.8 Ghz Intel Core i7 processor and 16 GB RAM, the execution of this command takes 3.91 seconds to run.

The following sections will provide additional details to the operations mentioned above, with more also on the auxiliary functions that are available in *flowcatchR*.




## Image acquisition

A set of images is acquired, after a proper microscopy setup has been performed. This includes for example a careful choice of spatial and temporal resolution; often a compromise must be met to have a good frame rate and a good SNR to detect the particles in the single frames. For a good review on the steps to be taken, please refer to Meijering's work. 

*flowcatchR* provides an S4 class that can store the information of a complete acquisition, namely `Frames`. The `Frames` class extends the `Image` class, defined in the *EBImage* package, and thus exploits the multi-dimensional array structures of the class. The locations of the images are stored as `dimnames` of the `Frames` object. To construct a `Frames` object from a set of images, the `read.Frames` function is used:

```{r newFrames, eval=FALSE}
# initialization
fullData <- read.Frames(image.files = "/path/to/folder/containing/images/",nframes=100) 
# printing summary information for the Frames object
fullData
```

`nframes` specifies the number of frames that will constitute the `Frames` object, whereas `image.files` is a vector of character strings with the full location of the (raw) images, or the path to the folder containing them (works automatically if images are in TIFF/JPG/PNG format). In this case we just loaded the full dataset, but for the demonstrational purpose of this vignette, we will proceed with the subset available in the `MesenteriumSubset` object, which we previously loaded.

It is possible to inspect the first frames of a `Frames` object with the function `inspect.Frames`.

```{r inspectRaw,fig.height=4,fig.width=7.5,fig.cap="The first 9 frames of the MesenteriumSubset dataset. The red channel stores information about platelets, while the green channel is dedicated to leukocytes"}
inspect.Frames(MesenteriumSubset,nframes=9,display.method="raster")

```


By default, `display.method` is set to `browser`, as in the *EBImage* function `display`. This opens up a window in the predefined browser (e.g. Mozilla Firefox), with navigable frames (arrows on the top left corner). For the vignette, we will set it to `raster`, for viewing them as raster graphics using R's native functions.

Importantly, these image sets were already registered and rotated in such a way that the overall direction of the movement of interest flows from left to right, as a visual aid and also to fit with some assumptions that will be done in the subsequent step of particle tracking. To register the images, we recommend the general purpose tools offered by suites such as ImageJ/Fiji.

For the following steps, we will focus on the information contained in the red channel, corresponding in this case to blood platelets. We do so by calling the channel.Frames` function:

```{r selectRed}
plateletsMesenterium <- channel.Frames(MesenteriumSubset, mode="red")
plateletsMesenterium
```


This creates another instance of the class `Frames`, and we inspect it in its first 9 frames.

```{r inspectPlatelets,fig.height=4,fig.width=7.5,fig.cap="The first 9 frames of the MesenteriumSubset dataset, just displaying the signal of the red channel (for the thrombocytes)"}
inspect.Frames(plateletsMesenterium,nframes=9,display.method="raster")
```


## Image preprocessing and analysis

Steps such as denoising, smoothing and morphological operations (erosion/dilation, opening/closing) can be performed thanks to the general functions provided by *EBImage*. *flowcatchR* offers a wrapper around a series of operations to be applied to all images in a `Frames` object. The function `preprocess.Frames` is called via the command:

```{r segmentPreprocess}
preprocessedPlatelets <- preprocess.Frames(plateletsMesenterium,
                                    brushSize = 3, brushShape = "disc",
                                    adaptOffset = 0.15, adaptWinWidth = 10, adaptWinHeight = 10,
                                    kernSize = 3, kernShape = "disc",
                                    watershedTolerance = 1, watershedRadius = 1,
                                    areaThresholdMin = 5, areaThresholdMax = 100)
preprocessedPlatelets
```


The result of this is displayed in the figure. 
For a detailed explanation of the parameters to better tweak the performances of this segmentation step, please refer to the help of `preprocess.Frames`. To obtain an immediate feedback about the effects of the operations performed in the full preprocessing phase, we can call again `inspect.Frames` on the `Frames` of segmented images.

```{r inspectSegm,fig.height=4,fig.width=7.5,fig.cap="The first 9 frames after preprocessing of the MesenteriumSubset dataset. The binarized image show the detected objects after thresholding."}
inspect.Frames(preprocessedPlatelets,nframes=9,display.method="raster")

```


The frames could be cropped, if e.g. it is needed to remove background noise that might be present close to the edges. This is done with the method for the function `crop.Frames`.

```{r cutFrames}
croppedFrames <- crop.Frames(plateletsMesenterium,
                     cutLeft=6,cutRight=6,
                     cutUp=3,cutDown=3,
                     testing=FALSE)
croppedFrames

```


If `testing` is set to true, the function just displays the first cropped frame, to get a feeling whether the choice of parameters was adequate. Similarly, for the function `rotate.Frames` the same behaviour is expected, whereas the rotation in degrees is specified by the parameter `angle`.

```{r rotateFrames}
rotatedFrames <- rotate.Frames(plateletsMesenterium,angle = 30)
rotatedFrames

```


If desired, it is possible to select just a subset of the frames belonging to a `Frames`. This can be done via the `select.Frames` function:

```{r subsetFrames}
subsetFrames <- select.Frames(plateletsMesenterium,
                       framesToKeep=c(1:10,14:20))
subsetFrames

```


The user can choose any combination of the operations in order to segment the images provided as input, but `preprocess.Frames` is a very convenient high level function for proceeding in the workflow. It is also possible, as it was shown in the introductory one-liner, to call just `particles` on the raw `Frames` object. In this latter case, `particles` computes the preprocessed `Frames` object according to default parameters. Still, in either situation, the output for this step is an object of the `ParticleSet` class.

```{r particleSet}
platelets <- particles(plateletsMesenterium,preprocessedPlatelets)
platelets

```

As it can be seen from the summary information, each `ParticleSet` stores the essential information on all particles that were detected in the original images, alongside with a complete set of features, which are computed by integrating the information from both the raw and the segmented frames.

A `ParticleSet` can be seen as a named list, where each element is a `data.frame` for a single frame, and the image source is stored as `names` to help backtracking the operations performed, and the slot `channel` is retained as selected in the initial steps.

It is possible to filter out particles according to their properties, such as area, shape and eccentricity. This is possible with the function `select.particles`. Thecurrent implementation regards only the surface extension, but any additional feature can be chosen and adopted to restrict the number of candidate particles according to particular properties which are expected and/or to remove potential noise that went through the preprocessing phase.

```{r selectParticles}
selectedPlatelets <- select.particles(platelets,min.area=3)

selectedPlatelets

```

  
This step can be done iteratively, with the help of the function `add.contours`. 
If called with the parameter mode set to `particles`, then it will automatically generate a `Frames` object, with the contours of all particles drawn around the objects that passed the segmentation (and filtering) step.

```{r checkSelection,fig.height=4,fig.width=7.5,fig.cap="Particles detected in the first 9 frames are shown in yellow, with their contours defined by the segmentation procedure."}
paintedPlatelets <- add.contours(raw.frames=MesenteriumSubset,
                                 binary.frames=preprocessedPlatelets,
                                 mode="particles")
inspect.Frames(paintedPlatelets,nframes=9,display.method="raster")

```


To connect the particles from one frame to the other, we perform first the detection of particles on all images. Only in a successive phase, we establish the links between the so identified objects. This topic will be covered in detail in the following section.



## Particle tracking

To establish the connections between particles, the function to be called is `link.particles`. The algorithm used to perform the tracking itself is an improved version of the original implementation of Sbalzarini and Koumotsakos. To summarize the method, it is a fast and efficient self-initializing feature point tracking algorithm (using the centroids of the objects as reference). The initial version is based on a particle matching algorithm, approached via a graph theory technique. It allows for appearances/disappearances of particles from the field of view, also temporarily as it happens in case of occlusions and objects leaving the plane of focus. 

Our implementation adds to the existing one by redefining the cost function used in the optimization phase of the link assignment, namely by adding two terms such as intensity variation and area variation, and mostly important with a function to penalize the movements that are either perpendicular or backwards with respect to the oriented flow of cells. Small unwanted movements, which may be present even after the registration phase, are handled with two jitter terms in a defined penalty function. Multiplicative factors can further influence the penalties given to each term.

In its default value, the penalty function is created via the `penaltyFunctionGenerator`. The user can exploit the parameter values in it to create a custom version of it, to match the particular needs stemming from the nature of the available data and phenomenon under inspection.

```{r penFunc}
defaultPenalty <- penaltyFunctionGenerator()
defaultPenalty

```

As mentioned above, to perform the linking of the particles, we use `link.particles`. Fundamental parameters are `L` and `r`, named as in the original implementation. `L` is the maximum displacement in pixels that a particle is expected to have in two consecutive frames, and `r` is the value for the link range, i.e. the number of future frames to be considered for the linking (typically assumes values between 1 - when no occlusions are known to happen - and 3). An extended explanation of the parameters is in the documentation of the package.

```{r linkParticles}
linkedPlatelets <- link.particles(platelets,
                                  L=26,R=3,
                                  epsilon1=0,epsilon2=0,
                                  lambda1=1,lambda2=0,
                                  penaltyFunction=penaltyFunctionGenerator(),
                                  include.area=FALSE)

linkedPlatelets

```

As it can be seen, `linkedPlatelets` is an object of the `LinkedParticleSet` class, which is also a `ParticleSet` class. 

After inspecting the trajectories it might be possible to filter a `LinkedParticleSet` class object, and subsequently reperform the linking on its updated version (e.g. some detected particles were found to be noise, and thus removed with `select.particles`)

*flowcatchR* provides functions to export and import the identified particles, in order to offer an additional entry point for tracking and analyzing the trajectories (if particles were detected with other routines) and also to store separately the information per each frame about the objects that were primarily identified.

An example is provided in the lines below, with the functions `export.particles` and `read.particles` :


```{r expo-impo,eval=FALSE}
# export to csv format
export.particles(platelets,dir = "/path/to/export/folder/exportParticleSet/")
# re-import the previously exported, in this case
reimportedPlatelets <- read.particles("/path/to/export/folder/exportParticleSet/")

```






## Trajectory analysis

It is possible to extract the trajectories with the correspondent `trajectories` function:

```{r generateTrajs}
trajPlatelets <- trajectories(linkedPlatelets)

trajPlatelets

```


A `TrajectorySet` object is returned in this case. It consists of a two level list for each trajectory, reporting the  `trajectory` as a `data.frame`, the number of points `npoints` (often coinciding with the number of `nframes`, when no gaps `ngaps` are present) and its `ID`. A `keep` flag is used for subsequent user evaluation purposes.

Before proceeding with the actual analysis of the trajectories, it is recommended to evaluate them by visual inspection. *flowcatchR* provides two complementary methods to do this, either plotting them (`plot` or `plot2D.TrajectorySet`) or drawing the contours of the points on the original image (`add.contours`).

By plotting all trajectories in a 2D+time representation, it's possible to have an overview of all trajectories. 

This command gives an interactive 3D (2D+time) view of all trajectories (output is not included in this vignette): 

```{r cubeTrajs,rgl=TRUE,fig.cap="A 2D+time representation of the trajectories, produced by plotting a TrajectorySet object",eval=TRUE}
plot(trajPlatelets,MesenteriumSubset)

```


The `plot2D.TrajectorySet` focuses on additional information and a different "point of view", but can just display the a two dimensional
projection of the identified trajectories.

```{r overviewTrajs,fig.height=4,fig.width=7.5,fig.cap='A 2D "flat" representation of the trajectories, more suitable to give an indication of the global movement'}
plot2D.TrajectorySet(trajPlatelets,MesenteriumSubset)

```


To have more insights on single trajectories, or on some of them, or also on all of them, `add.contours` offers a mode `trajectories`. Particles are drawn on the raw images with colours corresponding to the trajectory IDs `add.contours` plots by default all trajectories, but the user can supply a vector of the IDs of interest to override this behaviour.

```{r contourTrajs}
paintedTrajectories <- add.contours(raw.frames=MesenteriumSubset,
                                    binary.frames=preprocessedPlatelets,
                                    trajectoryset = trajPlatelets,
                                    mode="trajectories")
paintedTrajectories

```

As with any other `Frames` object, it is recommended to take a peek at it via the `inspect.Frames` function

```{r inspectTrajs,fig.height=4,fig.width=7.5,fig.cap="Particles detected in the first 9 frames are shown this time in colours corresponding to the identified trajectories, again with their contours defined by the segmentation procedure."}
inspect.Frames(paintedTrajectories,nframes=9,display.method="raster")

```

To allow for a thorough evaluation of the single trajectories, `export.Frames` is a valid helper, as it creates single images corresponding to each frame in the `Frames` object. We first extract for example trajectory 11 with the following command:

```{r traj11,fig.height=4,fig.width=7.5,fig.cap="First 9 frames for trajectory with ID 11, as supplied to the trajIds argument of add.contours"}
traj11 <- add.contours(raw.frames=MesenteriumSubset,
                       binary.frames=preprocessedPlatelets,
                       trajectoryset=trajPlatelets,
                       mode="trajectories",
                       trajIDs=11)
traj11
inspect.Frames(traj11,nframes=9,display.method="raster")

```

The data for trajectory 11 in the `TrajectorySet` object can be printed to the terminal: 

```{r viewTraj11}
trajPlatelets[[11]]
```

After that, it can also be exported with the following command (the `dir` parameter must be changed accordingly):

```{r exportTraj11,eval=FALSE}
export.Frames(traj11,nameStub="vignetteTest_traj11",
              createGif=TRUE,removeAfterCreatingGif=FALSE)
```


`export.Frames` offers multiple ways to export - animated gif (if `ImageMagick` is available and installed on the system) or multiple jpeg images.

Of course the user might want to evaluate singularly each trajectory that was identified, and this can be done by looping over the trajectory IDs.

```{r loopExport, cache=TRUE,eval=FALSE}
evaluatedTrajectories <- trajPlatelets

for(i in 1:length(trajPlatelets))
{
  paintedTraj <- add.contours(raw.frames=MesenteriumSubset,
                              binary.frames=preprocessedPlatelets,
                              trajectories=trajPlatelets,
                              mode="trajectories",
                              col="yellow",
                              trajIds=i)
  
  export.Frames(paintedTraj,
                nameStub=paste0("vignetteTest_evaluation_traj_oneByOne_",i),
                createGif=TRUE,removeAfterCreatingGif=TRUE)
  
  ### uncomment the code below to perform the interactive evaluation of the single trajectories

  #   cat("Should I keep this trajectory? --- 0: NO, 1:YES --- no other values allowed")
  #   userInput <- readLines(n = 1L)
  #   ## if neither 0 nor 1, do not update
  #   ## otherwise, this becomes the value for the field keep in the new TrajectorySet
  #   evaluatedTrajectories[[i]]$keep <- as.logical(as.numeric(userInput))
 
}
```


Always using trajectory 11 as example, we would set `evaluatedTrajectories[[11]]$keep` to `TRUE`, as the trajectory was correctly identified, as we just checked.

Once all trajectories have been selected, we can proceed to calculate (a set of) kinematic parameters, for a single or all trajectories in a `TrajectorySet` object. The function `kinematics` returns the desired output, respectively a `KinematicsFeatures` object, a `KinematicsFeaturesSet`, a single value or a vector (or list, if not coercible to vector) of these single values (one parameter for each trajectory).

```{r kinemFeats}
allKinematicFeats.allPlatelets <- kinematics(trajPlatelets,
                                             trajectoryID=NULL, # will select all trajectory IDs 
                                             acquisitionFrequency=30, # value in milliseconds
                                             scala=50, # 1 pixel is equivalent to ... micrometer
                                             feature=NULL) # all kinematic features available

```


As it is reported from the output, the function raises a warning for trajectories which have 3 or less points, as they might be spurious detections. In such cases, no kinematic features are computed.

```{r kinemInspect}
allKinematicFeats.allPlatelets

```


A summary for the returned object (in this case a `KinematicsFeaturesSet`) shows some of the computed parameters.
By default, information about the first trajectory is reported in brief, and the same parameters are evaluated on average across the selected trajectories. The true values can be accessed in this case for each trajectory by the subset operator for lists (`[[]]`), followed by the name of the kinematic feature (e.g., `$totalDistance`).

A list of all available parameters is printed with an error message if the user specifies an incorrect name, such as here:

```{r kinemFeatsAvailable}
allKinematicFeats.allPlatelets <- kinematics(trajPlatelets,feature="?")

```


When asking for a single parameter, the value returned is structured in a vector, such that it is straightforward to proceed with further analysis, e.g. by plotting the distribution of the curvilinear velocities.

```{r allVelos,fig.cap="Histogram of the curvilinear velocities for all trajectories identified in the MesenteriumSubset dataset",warning=FALSE}
allVelocities <- kinematics(trajPlatelets,feature="curvilinearVelocity")

hist(allVelocities, breaks=10, probability=TRUE,col = "cadetblue",
     xlab="Curvilinear Velocities Distribution",
     main="Trajectory Analysis: Curvilinear Velocities")
lines(density(allVelocities,na.rm=TRUE),col="steelblue",lwd = 2)

```

For this code chunk, we are suppressing the warning messages, as they would be exactly the same as in the former where all features were computed for each trajectory.


## Supplementary information

For more information on the method adapted for tracking cells, see Sbalzarini and Koumotsakos (2005).
For additional details regarding the functions of *flowcatchR*, please consult the documentation or write an email to (marinif@uni-mainz.de). 

Due to space limitations, the complete dataset for the acquired frames used in this vignette is not included as part of the flowcatchR package.
If you would like to get access to it, you can write an email to (marinif@uni-mainz.de).

## Acknowledgements
This package was developed at the Institute of Medical Biostatistics, Epidemiology and Informatics at the University Medical Center, Mainz (Germany), with the financial support provided by the TRP-A15 Translational Research Project grant. 

*flowcatchR* incorporates suggestions and feedback from the wet-lab biology units operating at the Center for Thrombosis and Hemostasis (CTH), in particular Sven Jäckel and Kerstin Jurk. Sven Jäckel also provided us with the sample acquisition which is available in this vignette.

We would like to thank the members of the Biostatistics division for valuable discussions, and additionally Isabella Zwiener for contributing to the first ideas on the project.

## Session Information
```{r sessioininfo,results='hold'}
sessionInfo()
# Sys.time()
```



















